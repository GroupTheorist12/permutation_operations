mod int_matrix;
use int_matrix::IntMatrix;

mod permutation;
use permutation::Permutation;

mod permutation_list;
use permutation_list::PermutationList;
use std::os::raw::c_char;

pub fn test_int_matrix() {
    let v1 = vec![2, 1, 3];

    let perm_matrix1 = IntMatrix::get_perm_matrix(v1);

    let v2 = vec![1, 3, 2];

    let perm_matrix2 = IntMatrix::get_perm_matrix(v2);

    let perm_matrix = perm_matrix1.clone() * perm_matrix2.clone();

    println!("{}", perm_matrix1);
    println!("{}", perm_matrix2);

    println!("permutaion matrix product:\n{}", perm_matrix);

    let tp = perm_matrix.clone().transpose();
    println!("permutation matrix transpose:\n{}", tp);

    let tp2 = perm_matrix.clone().inverse();
    println!("permutation matrix identity same as transpose:\n{}", tp2);

    let idn = perm_matrix.clone() * tp2.clone();
    println!(
        "The product of a permutation matrix and it's inverse is the identity\n{} {}",
        idn,
        idn.clone().identity()
    );
}

pub fn test_permutation() {
    let v = vec![1, 2, 3, 4, 5];

    let v1 = vec![3, 4, 5, 1, 2];
    let v2 = vec![3, 5, 1, 2, 4];

    let p1 = Permutation::new(v.clone(), v1);
    let p2 = Permutation::new(v.clone(), v2);

    let p3 = p1.clone() * p2.clone();

    println!("{}", p3);
    println!();

    let p_inv = p3.clone().inverse();
    println!("{}", p_inv);
    println!();

    let pm = p_inv.clone().get_perm_matrix();
    println!("{}", pm);
    println!();

    let is_ident = p3.clone() * p_inv;
    println!("{}", is_ident.identity());
}

pub fn test_permutation_list() {
    let v = vec![1, 2, 3, 4];

    let mut perms = PermutationList::new(4);

    perms.permute(v.clone());

    let the_perms = &perms;

    println!("{}", the_perms.perms.len());
    for perm in &the_perms.perms {
        print!("{}", perm);
        println!();
    }
}

pub fn test_latex() {
    let v = vec![1, 2, 3, 4, 5];

    let v1 = vec![3, 4, 5, 1, 2];

    let p1 = Permutation::new(v.clone(), v1);

    println!("{}", p1.get_perm_matrix().to_latex());
}

pub fn test_latex_out() {
    let v = vec![1, 2, 3, 4, 5];

    let v1 = vec![3, 4, 5, 1, 2];

    let p1 = Permutation::new(v.clone(), v1);

    let fil = String::from("mungout");

    createpdf_r(fil, p1.get_perm_matrix().to_latex());
}

pub fn test_permutation_list_latex() {
    let v = vec![1, 2, 3, 4];

    let mut perms = PermutationList::new(4);

    perms.permute(v.clone());

    let the_perms = &perms;

    let mut ind = 1;

    for perm in &the_perms.perms {
        print!("{}", perm.get_perm_matrix().to_latex());
        println!("\\quad");
        if ind % 4 == 0 {
            println!("\\\\\\\\");
        }

        ind = ind + 1;
    }
}

/* automatically generated by rust-bindgen 0.59.1 */

extern "C" {
    pub fn createpdf(fil: *mut ::std::os::raw::c_char, latex: *mut ::std::os::raw::c_char);
}

pub fn createpdf_r(fil: String, latex: String) {
    let bytes1: Vec<u8> = fil.into_bytes();
    let bytes2: Vec<u8> = latex.into_bytes();

    let mut c_chars1: Vec<i8> = bytes1.iter().map(| c | *c as i8).collect::<Vec<i8>>();
    
    c_chars1.push(0); // null terminator

    let mut c_chars2: Vec<i8> = bytes2.iter().map(| c | *c as i8).collect::<Vec<i8>>();
    
    c_chars2.push(0); // null terminator

    let ptr1: *mut c_char = c_chars1.as_mut_ptr();
    let ptr2: *mut c_char = c_chars2.as_mut_ptr();

    unsafe {
        createpdf(ptr1, ptr2);    

    }

}
fn main() {
    test_latex_out();
}
